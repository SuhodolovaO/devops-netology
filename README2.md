### Задача 1

Поиск запросов, выполняющихся более 3 минут    
**db.adminCommand( { currentOp: true, "active" : true, "secs_running" : { "$gt" : 180 } } )**  

Из ответа команды currentOp берем значение opid проблемного запроса и подставляем в следующую команду  
**db.adminCommand( { "killOp": 1, "op": <opid> } )**

Для решения проблемы зависающих запросов можно:  
- предложить разработчикам ограничивать время тяжелых запросов с помощью добавления метода cursor.maxTimeMS()  
- использовать метод explain() для анализа выполнения и возможной оптимизации таких запросов  

### Задача 2

Причина может быть в том, что в хранилище Redis образовалось слишком много истекших ключей одновременно.  
Redis периодически производит процесс очитски истекших ключей среди рандомно выбранных записей в количестве ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP (по умолчанию 20).
Если количество истекших ключей при каждом цикле очистки истекших данных превышает 25%, Redis может зациклиться в этом процессе и блокировать операции записи.  
Для разрешения таких ситуаций можно увеличить параметр ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP, что позволит снизить вероятность зацикливания в процессе очитски.

### Задача 3

Вероятно, при росте количества записей запросы стали выполняться слишком долго и возвращать слишком много данных, которые не успевают передаваться в ответе за время, указанное в настройке net_read_timeout.  
Локализовать проблемные запросы можно через механизм slow_log.  
Для решения проблемы можно:
- увеличить таймауты в настройках net_read_timeout, connect_timeout
- настроить гис-систему на более ограниченную выборку данных

### Задача 4

ОС завершает работу PostgreSQL из за нехватки оперативной памяти

Возможные решения:
- добавить оперативной памяти на сервере
- отключить использование huge_pages в настройках PostgreSQL или в ядре ОС
- применить горизонтальный шардинг для распределения данных по нескольким серверам