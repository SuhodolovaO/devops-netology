### 1. Используя знания из лекции по systemd, создайте самостоятельно простой unit-файл для node_exporter

После установки node_exporter создаем файл **/etc/systemd/system/node_exporter.service** со следующим содержимым:

[Unit]  
Description=Node_Exporter  

[Service]  
EnvironmentFile=/etc/default/node_exporter  
ExecStart=/usr/local/bin/node_exporter $EXTRA_OPTS  

[Install]  
WantedBy=multi-user.target  

Добавляем node_exporter в автозагрузку следующей командой:  
**$ systemctl enable node_exporter**  

При этом дополнительные опции могут задаваться через файл /etc/default/node_exporter, где указывается значение переменной EXTRA_OPTS  

**EXTRA_OPTS="--collector.disable-defaults --collector.cpu --collector.diskstats --collector.filesystem --collector.meminfo --collector.netdev"**

### 2. Приведите несколько опций, которые вы бы выбрали для базового мониторинга хоста по CPU, памяти, диску и сети.

Согласно описанию в Readme Node Exporter (https://github.com/prometheus/node_exporter) были выбраны следующие опции мониторинга:  
	
--collector.cpu  
--collector.diskstats  
--collector.filesystem  
--collector.meminfo  
--collector.netdev  

### 3. Ознакомьтесь с метриками, которые по умолчанию собираются Netdata и с комментариями, которые даны к этим метрикам.

На панели Netdata можно увидеть следующие основные метрики:  
cpu - использование ЦП  
load - число процессов, использующих ЦП  
disk - нагрузка на все дисковые устройства  
ram - использование памяти  
swap - использование файла подкачки  
network - нагрузка на физические сетевые интерфейсы  
processes - статистика процессов  
и другие метрики  

### 4. Можно ли по выводу dmesg понять, осознает ли ОС, что загружена не на настоящем оборудовании, а на системе виртуализации?

В выводе команды dmesg можно найти следующие строки, которые и позволяют определить загрузку ОС в VirtualBox:  

**DMI: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006**  
**Hypervisor detected: KVM**  

### 5. Как настроен sysctl fs.nr_open на системе по-умолчанию? 

Параметр fs.nr_open имеет следующее значение:  
**fs.nr_open = 1048576**

### Узнайте, что означает этот параметр. 
Судя по выводу команды **man proc** этот параметр ограничивает значение RLIMIT_NOFILE, которое задает максимальное количество файловых дескрипторов, возможных для открытия процессом.  

### Какой другой существующий лимит не позволит достичь такого числа (ulimit --help)?
Другая возможность ограничить количество открытых файловых дескрипторов процесса - задать ограничение в настройках оболочки  
**$ ulimit -n <число>**

### 6. Запустите любой долгоживущий процесс в отдельном неймспейсе процессов; покажите, что ваш процесс работает под PID 1 через nsenter.

Запускаем процесс в отдельном pid неймспейсе:  
**$ unshare -f --pid --mount-proc sleep 1h**  

Определяем pid запущенного процесса через основной неймспейс:  
**$ ps ax | grep sleep**
**2207 pts/1    S      0:00 sleep 1h**

Переключаемся на созданный через unshare неймспейс:  
**$ nsenter --target 2207 --pid --mount**

Проверяем pid процесса sleep в новом неймспейсе:
**$ ps ax | grep sleep**  
**1 pts/1    S      0:00 sleep 1h**  

### 7. Найдите информацию о том, что такое :(){ :|:& };:

Данная запись - это т.н. fork-бомба. Здесь :(){ :|:& }; - определение фукнциии с именем : в теле которой она рекурсивно вызывает сама себя в фоне. Последний символ : - это запуск созданной функции.  
При ее запуске начинается порождение дочерних процессов до тех пор, пока их количество не достигнет максимума  

В выводе dmesg можно увидеть следующую строку:  
**cgroup: fork rejected by pids controller in /user.slice/user-1000.slice/session-1.scope**  
Откуда следует, что ограничение количества процессов достигнуто через механизм cgroup  

Настройка максимального количества процессов в механизме cgroup задается в файле  
/sys/fs/cgroup/pids/user.slice/user-1000.slice/session-1.scope/pids.max  
По умолчанию этот файл содрежит значение **max**, что означает отсутсвие ограничений. Здесь же можно задать число, ограничивающее количество процессов.
