### 1. Какой системный вызов делает команда cd?
  
Сначала выполняем команду  
**$ strace /bin/bash -c 'cd /tmp'**  

В выдаче команды есть строка  
**chdir("/tmp")**  
Из чего можно сделать вывод, что chdir и есть искомый системный вызов

### 2. Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.

Сначала выполняем команду по поиску открываемых файлов при выполнении команды file  
**$ strace file /bin/bash 2>&1 | grep open**  
Анализируя полученные пути к файлам, определяем, что искомый файл - /usr/share/misc/magic.mgc

### 3. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла.

Запускаем в фоне предварительно написанный python скрипт, пишущий в файл py_log.txt  
**$python3 py_script.py &**  
**1589**  
Удаляем файл py_log.txt  
**$rm py_log.txt**  
Находим в списке дескрипторов файлов процесса удаленный файл  
**$ll /proc/1589/fd**  
По результатам выдачи данной команды определяем дескриптор удаленного файла - 3  
Записываем пустую строку в данный дескриптор  
**echo > /proc/1589/fd/3**

### 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

Зомби-процессы не потребляют ресурсов, но занимают место в таблице процессов, что может привести к достижению ее лимита и невозможности создавать новые процессы.

### 5. На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты opensnoop?
/var/run/utmp  
/usr/local/share/dbus-1/system-services  
/usr/share/dbus-1/system-services  
/lib/dbus-1/system-services  
/var/lib/snapd/dbus-1/system-services/  
/proc/interrupts/  
/proc/stat/  
/proc/irq/20/smp_affinity/  
/proc/irq/0/smp_affinity/  
/proc/irq/1/smp_affinity/  
/proc/irq/8/smp_affinity/  
/proc/irq/12/smp_affinity/  
/proc/irq/14/smp_affinity/  
/proc/irq/15/smp_affinity/  

### 6. Какой системный вызов использует uname -a?

По результатам выдачи команды  
**strace uname -a**  
получаем, что искомый системный вызов - uname.

### Приведите цитату из man по этому системному вызову  
Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.  

### 7. Чем отличается последовательность команд через ; и через && в bash?

При разделении команд символом ; они будут выполняться последовательно вне зависимости от успешности выполнения.  
При разделении через && последующие команды будут выполняться только при успешном завершении предыдущей.  

### Есть ли смысл использовать в bash &&, если применить set -e?
Согласно мануалу, команда **set -e** завершает выполнение пайплайна, если очередная команда вернула ненулевой статус. Объединение команд через && имеет тот же эффект.  
Следовательно, совместное использование && и **set -e** смысла не имеет.

### 8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?

Данный режим включает следующие опции:  
-e - завершить выполнение пайплайна, если очередная команда вернула ненулевой статус  
-u - выдавать ошибку в случае не установленных параметров  
-x - выводить каждую команду с аргументами перед ее выполнением  
-o pipefail - в качестве результата пайплайна выдается результат последней команды, завершившейся с ненулевым статусом. Если весь пайплайн завершен успешно, то результатом будет 0  

Такой режим будет удобен при отладке сценария.

### 9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе.

**$ ps ax -o stat | cut -c 1 | sort | uniq -c **  
**51 I**  
**1 R**  
**58 S**  

Как видно из вывода данной команды, самый частый статус - S (ожидание события)